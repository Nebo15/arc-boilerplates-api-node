/**
 * This helper implements gateway-based API versioning. (Originally idea taken from Stripe.)
 *
 * On every request we collect API version header and collect all gates that is newer than specified version,
 * then we apply this mutators of gates to request and response.
 *
 * There are two types of mutators:
 * - request mutator - that allows you to override any request parameter you want.
 * - response mutator - that can transform object generated by "JSON View Controller"
 *   into another structure.
 *
 * This approach helps to forget about versioning in your code, maintaining only newest version, and to leave all
 * back-portability pain in request-response gates.
 */

import fs from 'fs';
import moment from 'moment';
import config from './../settings/config';
import async from 'async';

// Cache FS operations
let gates_cache = {};

let getLatestAPIVersion = () => {
  return moment().format("YYYY-MM-DD");
};

// TODO: Move this to a separate middleware and return appropriate json error
let getRequestedVersion = (req) => {
  let version_header = config.get('gates').get('versionHeader');
  let version = version_header ? req.headers[version_header.toLowerCase()] : undefined;

  if (version !== undefined) {
    if (!version.match(/[0-9]{4}-[0-9]{2}-[0-9]{2}/g)) {
      throw new Error("Incorrect API version.");
    }

    return version;
  }

  return getLatestAPIVersion();
};

let requireGate = (gate, dir) => {
  dir = dir || config.get('gates').get('dir');
  return require(`${dir}/${gate}.js`).default;
};

let getActiveGates = (base_version) => {
  if (gates_cache[base_version]) {
    return gates_cache[base_version];
  }

  let gates_list = [];
  let latest_moment = moment(getLatestAPIVersion());
  let base_moment = moment(base_version);

  console.log(base_version);

  let files = fs.readdirSync(config.get('gates').get('dir')) || [];
  if (files && files.length > 0) {
    for (let i in files) {
      let gate_name = files[i].split('.');
      if (gate_name.length < 2 || gate_name[1] !== 'js') {
        continue;
      }

      let gate_moment = moment(gate_name[0]);

      console.log(gate_moment.format("YYYY-MM-DD"), latest_moment.format("YYYY-MM-DD"));
      if (gate_moment.isBetween(base_moment, latest_moment)) {
        gates_list.push(gate_name[0]);
      }
    }
  }

  gates_list.sort((lhs, rhs) => {
    lhs = moment(lhs);
    rhs = moment(rhs);
    return lhs.isAfter(rhs) ? -1 : lhs.isBefore(rhs) ? 1 : 0;
  });

  let gates = gates_list.map((gate) => {
    let g = requireGate(gate);

    if (!g) {
      throw new Error(`Gate ${gate} don't have default export!`);
    }

    if (!g instanceof VersionGate) {
      throw new Error(`Gate ${gate} doesn't extend VersionGate!`);
    }

    g.version = gate;

    return g;
  });

  gates_cache[base_version] = gates;

  return gates;
};

export class VersionGate {
  static requestMutator(req, cb) {
    return cb(null);
  }

  static responseMutator(data, res, cb) {
    return cb(null);
  }

  static getChangelog() {
    return "Undescribed breaking change.";
  }
}

export let gateRequestMiddleware = () => {
  return (req, res, next) => {
    let version = getRequestedVersion(req);

    // Get list of request mutator functions
    let request_mutators = getActiveGates(version).map((g) => {
      if (g.requestMutator) {
        return (cb) => {
          g.requestMutator(req, cb);
        };
      }

      return undefined;
    }).filter((g) => {
      return g !== undefined;
    });

    // Apply all mutators
    async.waterfall(request_mutators, (err) => {
      if (err) {
        throw new Error("There was en error while applying one of request gates.");
      }

      return next(err);
    });
  };
};

export let gateResponseMutator = () => {
  return (req, res, data, done) => {
    let version = getRequestedVersion(req);

    // Get list of response mutator functions
    let response_mutators = getActiveGates(version).map((g) => {
      if (g.responseMutator) {
        return (cb) => {
          g.responseMutator(data, res, cb);
        };
      }

      return undefined;
    }).filter((g) => {
      return g !== undefined;
    });

    // Apply all mutators
    async.waterfall(response_mutators, (err) => {
      if (err) {
        throw new Error("There was en error while applying one of response gates.");
      }

      return done(err, data);
    });
  };
};
